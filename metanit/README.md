# [Metanit, Go Course](https://metanit.com/go)

## Дополнительная информация

- [ ] Дополнить 7 главу, https://www.youtube.com/watch?v=wHQBMDInWEg
- [ ] Что такое рантайм
- [ ] Что такое конкурентность
- [ ] Deadlock, lifelock
- [ ] Баласт в Go
- [ ] Хэш процессора
- [ ] Балун Go - канал
- [ ] Устройство мапы и слайса
- [ ] Примитивы синхронизации Go
- [ ] Общие примитивы синхронизации, симофор
- [ ] Lock Free Stack. Отличие хипа от стэка
- [ ] Куча памяти, хип, стэк, аллокация
- [ ] Зеленый поток
- [ ] select в каналах
- [ ] Уровни абстракции в кубере
- [ ] https://habr.com/ru/companies/mvideo/articles/778248/
- [ ] https://medium.com/clean-code-channel/go-memory-ballast-dec0c04830b1
- [ ] Конспект https://www.youtube.com/watch?v=_rTuAY7b1RE
- [ ] Конспект https://habr.com/ru/companies/nixys/articles/461723/
- [ ] Конспект https://habr.com/ru/articles/710644/
- [ ] Устройство арены, mspan (зона в арене)
- [ ] Алгоритм GC (чем отличается алгоритм Go от GC поколений, дефолтных)
- [ ] TCP, мультипликсирование
- [ ] Escape анализ (как определить где выделиться память: в стеке или в куче)
- [ ] Устройство планировщика
- [ ] Нетполлер, сисмон
- [ ] Как устроены локальные глобальные очереди
- [ ] Ворк стиллинг
- [ ] Статья про память https://habr.com/ru/companies/oleg-bunin/articles/676332/
- [ ] Про работу GC https://tip.golang.org/doc/gc-guide
- [ ] Worker Poll 


## Глава 4. Производные типы

#### Именованные типы и псевдонимы

Оператор **type** позволяет определить тип на основе уже имеющегося типа 

```go
type mile uint
```

**Особенности:**
1. Доступны методы базового типа
2. Базовый тип и именнованный не являются одним и тем же. Их нельзя подставить друг под друга, зато можно преобразовать

**Применения:**
1. Сокращение длинных имен, особенно полезно при работе с сигнатурой функции
2. Придать типу дополнительный явный смысл
3. Снизить количество ошибок по типу передачи неверных аргументов при работе с базовыми типами

```go
type BinaryOp func(int, int) int
 
func action(n1 int, n2 int, op BinaryOp){
    result := op(n1, n2)
    fmt.Println(result)
}
```

**Псевдонимы** - по сути похожи на именованные типы, но не определяют нового типа. Применяются для сокращения названий других типов или определения более описательного имени

```go
type mile = uint
```

#### Структуры

Структуры определяют тип данных, определяемый разработчиком и служащий для представления каких-либо объектов. Определяется с помощью ключевых слов **type** и **struct**. Структура является новым типом данных

```go
type имя_структуры struct{
    поля_структуры
}
```

С помощью инициализатора можно передать структуре начальные значения. Если не указывать значения, то они поля структуры примут значения по умолчанию

```go
var alice person = person{"Tom", 23}
var bob = person {name: "Tom", age: 24}
```

Можно создавать указатели на структуру. Можно создавать указатели на отдельные поля структуры. Для получения значения поля структуры по её указателю можно его разыменовать, а можно и просто напрямую обратиться к полю

```go
tom := person {name: "Tom", age: 22}
var tomPointer *person = &tom

tomPointer.age = 29
fmt.Println(tom.age) // 29

(*tomPointer).age = 32
fmt.Println(tom.age) // 32

var agePointer *int = &tom.age // указатель на поле tom.age
*agePointer = 35 // изменяем значение поля
fmt.Println(tom.age) //  35
```

Для инициализации указателя на структуру не обязательно присваивать ему адрес именованной переменной. Можно присвоить адрес безымянного объекта следующим образом: 

```go
var tom *person = &person{name:"Tom", age:23}
var bob *person = new(person)
```

#### Вложенные структуры

Поля структур могут представлять другие структуры

```go
type contact struct{
    email string
    phone string
}
 
type person struct{
    name string
    age int
    contactInfo contact
}

// Сокращенная запись
type student struct {
	name string
	contact // Сразу и тип, и имя
}

func main() {
	student.email = "qwe" // короткое обращение
}
```

Структура не может хранить поле, представляющая тип этой же структуры. Но может хранить указатель на этот же тип

```go
type node struct {
	value int
	next node //! Ошибка
}

type node struct {
	value int
	next *node // Правильно
}

func main() {
     
    first := node{value: 4}
    second := node{value: 5}
    third := node{value: 6}
     
    first.next = &second
    second.next = &third
     
    var current *node = &first
    for current != nil{
        fmt.Println(current.value)
        current = current.next
    }
}
```

#### Методы

Метод представляет функцию, связанную с определенным типом

```go
type library []string

func (l library) print(){
    for _, val := range l{
        fmt.Println(val)
    }
}
```

#### Методы указателей

При вызове метода, объект структуры, для которого определен метод, передается в него по значению. Если же мы хотим изменить значение в передаваемой структуре, то необходимо передавать указатель

```go
type person struct{
    name string
    age int
}
func (p *person) updateAge(newAge int){
    (*p).age = newAge
}
```


#### Дополнительно. Теги структуры

В Go **struct tag** - это строка, ассоциированная с полями структуры, которая используется для хранения метаинформации в поле. Она записывается в обратных кавычках `json:"id"` и располагается сразу после объявления поля структуры

```go
type User struct {
	Name string `json:"name"`
}
```

Struct tag может быть использован для передачи информации различным библиотекам, например, для сериализации и десериализации данных, валидации и других целей

##### Аннотации для JSON

```go
type User struct {
    ID    int    `json:"id"`
    Email string `json:"email,omitempty"`
}
```


**omitempty** - если поле имеет нулевое значение для своего типа, то оно не будет включено в результирующий JSON. Опция omitempty позволяет избежать отправки пустых полей

##### Валидация полей

```go
type User struct {
    URL  string `validate:"required,url"`
    Email string `validate:"required,email"`
}
```

##### Синтаксис и формат

Struct tag состоит из нескольких частей, разделенных пробелми. Каждая часть - это строка формата key-value

```go
type Example struct {
    Field1 string `json:"field1" xml:"field_one"`
    Field2 int    `validate:"min=0,max=100" db:"field_two"`
}
```

##### Доступ в коде

Для доступа к struct tag можно использовать **рефлексию**:

```go
import (
    "fmt"
    "reflect"
)

type User struct {
    Name  string `json:"name" validate:"required"`
    Email string `json:"email" validate:"email"`
}

func main() {
    t := reflect.TypeOf(User{})
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field: %s, JSON Tag: %s, Validate Tag: %s\n",
            field.Name,
            field.Tag.Get("json"),
            field.Tag.Get("validate"))
    }
}
```



## Глава 5. Пакеты и модули

### Пакеты и их импорт

Весь код организуется в пакеты. Для определения пакета применяется ключевое слово **package**. Определение пакета должно идти в начале файла

```go
package main
```

Есть два вида пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя **main**. Все остальные пакеты являются библиотеками. Пакет может состоять из множества файлов

#### Импорт пакетов

Можно импортировать как собственные, так и встроенные пакеты

```go
import (
	"fmt"
	"math"
)
```

Список встроенных пакетов [https://golang.org/pkg/](https://golang.org/pkg/)

Если функция или структура написана с заглавной буквы, то она доступна для экспорта и видна в других пакетах. Если с маленькой, то область видимости ограничена текущим пакетом

### Введение в модули

Модули представляют набор пакетов Go, которые имеют встроенное версионирование и которые мы можем опубликовать для использования в других проектах. Начиная с версии Go 1.16, для использования внешних модулей необходимо определить свой модуль

#### Создание модуля

Для создания модуля применяется команда в которую передается имя модуля

```go
go mod init имямодуля
```

Для актуализации пакетов в проекте можно использовать команду

```go
go mod tidy [-v]
```

#### Подключение модулей

Для подключения модулей используется команда

```go
go get rsc.io/quote
```

Скаченный модуль запишется в файл go.mod в директиву require(), для проверки **контрольной суммы** #выучить появится запись в файле go.sum. Все загружаемые пакеты хранятся по пути $GOPATH/pkg/mod.



## Глава 6. Интерфейсы

Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации

```go
type имя_интерфейса interface{
    определения_функций
}
```

> **В Go интерфейс реализуется неявно.**  Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс

##### Соответствие интерфейсу

Чтобы тип данных соответствовал интерфейсу, он должен реализовать все методы этого интерфейса. Структура также может имплементировать несколько интерфейсов одновременно

##### Вложенные интерфейсы

Одни интерфейсы могут содержать другие интерфейсы. В этом случае для соответствия подобному интерфейсу типы данных должны реализовывать все его вложенные интерфейсы

```go
type Reader interface {
	read()
}

type Writer interface {
	write(string)
}

type ReaderWriter interface {
	Reader
	Writer
}
```

##### Полиморфизм

Полиморфизм представляет возможность принимать многообразные формы. В зависимости от реального типа структуры динамически определяется, какая именно реализация метода для какой структуры должна вызываться

## Глава 7. Параллельное программирование, горутины

Горутины (goroutines) представляют паралелльные операции, которые могут выполнять независимо от функции, в которой они были запущены. Главная особенность горутин в том, что они могут выполняться параллельно. Более строгое определение

Горутина - это функция, выполняющаяся конкуретно с другими горутинами в том же адресном пространстве. Горутины легковесны, практически все расходы - это создание стека, который очень невелик, в среднем можно рассчитывать на 4.5 килобайта на одну горутину

Польза от горутин только если
1. Нужна ассинхронность, например, работа с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п. 
2. Если время выполнения функции достаточно велико и можно получить выигрыш, нагрузив другие ядра

```go
runtime.GOMAXPROCS(n int) // Число работающих машин
runtime.Gosched() // Вернуть горутину в очередь
```

Каждая горутина, как правило, предоставляет вызов функции, и последовательно выполняет все свои инструкции. Когда мы запускаем программу на Go, мы уже работает как минимум с одной горутиной, которая представлена функцией main

Стоит отметить, что так каждая горутина запускается в своем собственном контексте и выполняется независимо и параллельно по сравнению с другими горутинами, то **невозможно чётко детерминировать, какая из горутин завершится раньше**  


| Потоки                                                                                     | Горутины                                                                                                                              |
| ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| Потоки ОС управляются ядром ОС                                                             | Горутины управляются "рантаймом" Go                                                                                                   |
| Потоки ОС в основном имеют фиксированный размер в 1-2MB                                    | Горутины обычно имеют размер стэка 2-6KB                                                                                              |
| Размер стэка определяется во время компиляции и не может увеличиваться                     | Размер стэка определяется во время рантайма и может расти вплоть до 1GV что возможно благодаря аллокации и освобождения места из хипа |
| У потоков нет простого способа коммуникации между собой. Такая коммуникация имеет задержку | Горутины используют "каналы" для быстрого обращения между собой с маленькой задержкой                                                 |

##### Каналы

Каналы (channels) представляют инструмент коммуникации между горутинами. Для определения канала применяется ключевое слово **chan**

```go
chan тип_элемента

var intCh chan int
```

###### Небуфферизированные каналы

Для создания небуферизированного канала вызывается функция make() без указания ёмкости канала

```go
var intCh chan int = make(chan int)
strCh = make(chan string)
```

Если канал пустой, то горутина получатель блокируется, пока в канале отправителе не окажутся данные. Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные и возобновляет работу

**Горутина-отправитель может отправлять данные только в пустой канал**. Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены

Стоит отметить, что одномоментно одна горутина должна отправлять данные, а другая - получать. Например, если мы определеим отправление и получение данных через один и тот же канал в одной и той же горутине, то мы столкнемся с взаимоблокировкой - deadlock

###### Буферизированные каналы

Буферизированные каналы также создаются с помощью make(), только в качестве второго аргумента в функцию передается ёмкость канала. Если канал пуст, то получатель ждёт, пока в канале появится хотя бы один элемент. При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для ещё одного элемента и отправляет элемент только тогда, когда в канале освобождается для него место

```go
package main
import "fmt"
 
func main() {
    intCh := make(chan int, 3) 
    intCh <- 10
    intCh <- 3
    intCh <- 24
    fmt.Println(<-intCh)     // 10
    fmt.Println(<-intCh)     // 3
    fmt.Println(<-intCh)     //24
}
```

С помощью встроенных функция cap() и len() можно получить соответственно ёмкость и количество элементов в канале
###### Однонаправленные каналы

В Go можно определить канал, как доступный только для отправки данных или только для получения данных

```go
var inCh chan<- int // канал только для отправкки данных
var outCh <-chan int // канал только для получения данных

func factorial(n int, ch chan<- int){}
```

###### Возвращение канала

Канал может быть возвращаемым значением функции. Все операции чтения-аписи в канал следует вынести в отдельную горутину

```go
package main
import "fmt"
  
func main() {
    fmt.Println("Start")
     // создание канала и получение из него данных
    fmt.Println(<-createChan(5)) // 5, блокировки не случится
    fmt.Println("End")
}
func createChan(n int) chan int{
    ch := make(chan int)    // создаем канал
    go func(){
        ch <- n      // отправляем данные в канал
    }()             // запускаем горутину
    return ch   // возвращаем канал
}
```

